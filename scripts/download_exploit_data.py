# download_exploit_data.py

import os
import time
import requests
import pandas as pd
from pathlib import Path
from tqdm import tqdm
from typing import List, Dict, Any, Optional

# CONFIGURATION

# 1. PASTE YOUR ETHERSCAN API KEY HERE
ETHERSCAN_API_KEY = "YOUR_ETHERSCAN_API_KEY"

# 2. SET YOUR TARGET DOWNLOAD DIRECTORY
# The script will create subfolders for each exploit inside this directory.
BASE_DOWNLOAD_DIR = Path("your/download/directory/here")

# 3. SET A TRANSACTION LIMIT PER EXPLOIT
# This prevents CSV files from becoming too large. Set to None for no limit.
MAX_TRANSACTIONS_PER_EXPLOIT = 20000 # Good for a large but manageable dataset

# 3. DEFINE THE EXPLOITS AND SEED ADDRESSES
# This list contains the primary attacker's address for each major exploit.
EXPLOITS = [
    {
        "name": "ronin_bridge_hack",
        "seed_address": "0x098B716B8Aaf21512996dC57EB0615e2383E2f96"
    },
    {
        "name": "wormhole_bridge_hack",
        "seed_address": "0x629e7Da20197a5429d30da36E77d06CdF796b71A"
    },
    {
        "name": "poly_network_hack",
        "seed_address": "0xC8a65Fadf0e0dDAf421F28FEAb69Bf6E2E589963"
    },
    {
        "name": "euler_finance_hack",
        "seed_address": "0xb66cd966670d962c227b3eaba30a872dbfb995db"
    },
    # The DAO hack is very old and its transaction structure is different.
    # It's better to analyze it from the child DAO contract perspective.
    {
        "name": "the_dao_hack",
        "seed_address": "0x304a554a310c7e546dfe434669c62820b7d83490"
    },
]

# Updated Etherscan V2 API endpoint
API_URL = "https://api.etherscan.io/v2/api"

def fetch_transactions_for_address(address: str, max_transactions: Optional[int] = None) -> List[Dict[str, Any]]:
    """
    Fetches all 'normal' transactions for a given Ethereum address from Etherscan.
    """
    all_transactions = []
    start_block = 0
    
    while True:
        params = {
            "module": "account",
            "action": "txlist",
            "address": address,
            "startblock": start_block,
            "endblock": 99999999,
            "sort": "asc",
            "apikey": ETHERSCAN_API_KEY,
        }
        try:
            response = requests.get(API_URL, params=params)
            response.raise_for_status()  # Raise an exception for bad status codes
            data = response.json()

            if data["status"] == "1":
                transactions = data["result"]
                all_transactions.extend(transactions)
                
                # Check if we have reached the user-defined limit
                if max_transactions and len(all_transactions) >= max_transactions:
                    print(f"    - Reached transaction limit of {max_transactions}. Stopping download for this address.")
                    return all_transactions[:max_transactions]

                # Etherscan returns up to 10,000 records per call.
                # If we get 10,000, we need to paginate.
                if len(transactions) == 10000:
                    # Next request starts from the block after the last one
                    print(f"    - Fetched {len(all_transactions)} transactions so far, paginating...")
                    start_block = int(transactions[-1]["blockNumber"]) + 1
                    time.sleep(0.2) # Respect API rate limit
                else:
                    break # We have all transactions
            elif data["status"] == "0" and "rate limit" in data["message"].lower():
                print("Rate limit reached. Waiting for 5 seconds...")
                time.sleep(5)
            elif data["status"] == "0" and "invalid api key" in data["message"].lower():
                print("\n‚ùå FATAL ERROR: The Etherscan API key is invalid.")
                print("   Please check your API key in the script and try again.")
                return None # Return None to indicate a fatal error
            else:
                # No more transactions or an error occurred
                break
        except requests.exceptions.RequestException as e:
            print(f"An error occurred during API request: {e}")
            break
        except Exception as e:
            print(f"An unexpected error occurred: {e}")
            break
            
    return all_transactions

def process_and_save_transactions(transactions: List[Dict[str, Any]], seed_address: str, exploit_dir: Path):
    """
    Processes raw transaction data and saves it to deposit/withdraw CSV files.
    """
    deposits = []
    withdrawals = []

    # Normalize addresses to lowercase for consistent comparison
    seed_address_lower = seed_address.lower()

    for tx in transactions:
        # Define the record to be saved, matching your pipeline's expected format
        record = {
            "hash": tx.get("hash"),
            "from_addr": tx.get("from"),
            "to_addr": tx.get("to"),
            "value": tx.get("value"),
            "timestamp": tx.get("timeStamp"),
            "block_number": tx.get("blockNumber"),
            "gas": tx.get("gas"),
            "gas_price": tx.get("gasPrice"),
            "method_name": tx.get("functionName"), # Etherscan uses 'functionName'
            "function_name": tx.get("functionName"),
        }

        # Determine if it's a deposit or withdrawal relative to the seed address
        if tx.get("to", "").lower() == seed_address_lower:
            deposits.append(record)
        elif tx.get("from", "").lower() == seed_address_lower:
            withdrawals.append(record)

    # Create directories if they don't exist
    deposit_dir = exploit_dir / "deposit"
    withdraw_dir = exploit_dir / "withdraw"
    deposit_dir.mkdir(parents=True, exist_ok=True)
    withdraw_dir.mkdir(parents=True, exist_ok=True)

    # Save to CSV files
    if deposits:
        df_deposits = pd.DataFrame(deposits)
        deposit_path = deposit_dir / "deposits.csv"
        df_deposits.to_csv(deposit_path, index=False)
        print(f"    - Saved {len(deposits)} deposit transactions to {deposit_path}")

    if withdrawals:
        df_withdrawals = pd.DataFrame(withdrawals)
        withdrawal_path = withdraw_dir / "withdrawals.csv"
        df_withdrawals.to_csv(withdrawal_path, index=False)
        print(f"    - Saved {len(withdrawals)} withdrawal transactions to {withdrawal_path}")

def main():
    """
    Main function to orchestrate the download and processing of exploit data.
    """
    print("üöÄ Starting Forensic Dataset Downloader...")
    
    if ETHERSCAN_API_KEY == "YOUR_ETHERSCAN_API_KEY":
        print("‚ùå ERROR: Please set your ETHERSCAN_API_KEY in the script before running.")
        return

    BASE_DOWNLOAD_DIR.mkdir(parents=True, exist_ok=True)
    print(f"üíæ Datasets will be saved to: {BASE_DOWNLOAD_DIR}\n")

    for exploit in tqdm(EXPLOITS, desc="Processing Exploits"):
        exploit_name = exploit["name"]
        seed_address = exploit["seed_address"]
        
        print(f"\nProcessing exploit: {exploit_name} (Address: {seed_address[:10]}...)")
        
        # Create a directory for the exploit
        exploit_dir = BASE_DOWNLOAD_DIR / exploit_name
        exploit_dir.mkdir(exist_ok=True)

        # Fetch all transactions for the seed address
        print("  - Fetching transactions from Etherscan API...")
        transactions = fetch_transactions_for_address(seed_address, max_transactions=MAX_TRANSACTIONS_PER_EXPLOIT)
        
        # If fetch_transactions returns None, it's a fatal API key error.
        if transactions is None:
            return # Stop the script

        if not transactions: # This now only handles the "no transactions found" case
            print("    - No transactions found or an API error occurred. Skipping.")
            continue
            
        print(f"    - Found {len(transactions)} total transactions.")

        # Process and save the transactions into the correct subfolders
        process_and_save_transactions(transactions, seed_address, exploit_dir)

    print("\nüéâ All datasets downloaded successfully!")

if __name__ == "__main__":
    main()